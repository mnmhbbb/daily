2022.10.14.Fri.

# 테스트 코드(프론트엔드에서의 테스트 코드)

테스트 코드의 장점

- 발견하지 못 한 버그를 빠르게 검사할 수 있음
- 코드를 수정했을 때, 실수로 기존의 기능을 망가뜨리는 것을 방지할 수 있음
- 코드 리팩토링을 수행한 후 이전과 동일하게 동작하는지 검증하기 쉬움
- 개발할 때 발생할 수 있는 상황에 대해 미리 정리해놓고 작업을 하면 실수로 빠뜨릴 수 있는 사항을 잘 챙길 수 있게 됨
- 테스트 코드를 작성하더라도 버그가 발생할 수는 있음. 그러나 해당 버그를 고친 다음 해당 케이스에 대한 테스트 코드를 작성해놓으면 같은 버그가 생기는 것을 방지할 수 있음
- 테스트 코드가 명세서의 역할을 하여 코드를 파악하는 데 도움을 줌

<br />

테스트 코드를 작성하면서 주의할 점

- 실패해야 할 상황에서 테스트가 성공하면 잘못된 코드를 발견하지 못하고 버그가 존재하는 상태로 배포될 수 있음
- 단순히 커버리지를 높이기 위해 테스트를 진행하고 있는 건 아닌지. 커버리지 100%를 목표로 하는 것은 비효율적
- 테스트 코드도 실제 코드와 동일한 기준으로 품질 관리를 해야 함
- 테스트 코드를 보고 한 눈에 어떤 내용을 테스트하는지를 파악할 수 있어야 함.
- 앱의 사용자 입장에서 반드시 확인해야 하는 항목은 무엇인지 체크
- 테스트 범위에 대한 조절이 필요 (단위 테스트 vs 통합 테스트 vs E2E 테스트)
  - 모든 모듈에 대해 단위 테스트를 작성하는 것은 비효율적
  - 모든 테스트 케이스를 E2E 테스트로만 검증하는 것도 비효율적
  - (https://nhnent.dooray.com/share/posts/9jRYF1fxRwiCvwi6VM0VgA)

<br />

프론트엔드 개발자가 수행하는 테스트

- 디자인을 보고 마크업을 한 뒤, 브라우저에서 렌더링 된 결과를 확인하는 일련의 과정
- 새로운 기능을 추가한 뒤 제대로 동작하는지 브라우저에서 확인하는 것
- 기존 코드를 리팩토링한 후 영향을 받는 다른 모듈이 기존과 동일하게 동작하는지 확인하는 것

<br />
<br />

## 테스트 유형

1. 정적(Static) 테스트
   - 코드를 실행시키지 않고 테스트를 하는 것
   - 정적 테스트를 하면 Type 에러나 Reference 에러와 같은 개발자의 실수로 인해 발생하는 에러를 미연에 방지
   - 많은 개발자의 노하우에 의해 만들어진 규칙에 따라 코드를 분석하는 것은 더 좋은 코드를 작성할 수 있는 습관을 기르도록 도와줌
   - **프론트엔드**의 경우 **ESLint** 를 활용하여 사용하지 않는 변수를 찾거나 Typescript 로 함수의 인자로 받는 파라미터의 타입 검사를 하는 것이 정적 테스트에 포함됨
2. 단위(Unit) 테스트
   - 각 모듈을 단독 실행 환경에서 독립적으로 테스트하는 것
   - Sociable 테스트: 의존성이 있는 코드와 함께 테스트
   - Solitary 테스트: 모듈에 의해 실행되는 코드를 **\*테스트 더블**로 대체
     - \*테스트 더블(Test Double)이란 실제 객체 대신 테스트를 위해 동작하는 객체
   - ![unit-test](https://martinfowler.com/bliki/images/unitTest/isolate.png)
   - **프론트엔드**에서 단위 테스트는 특정 컴포넌트를 렌더링해서 깨지지 않는지 확인하는 것
     - Sociable 테스트는 자식(child) 컴포넌트까지 포함해서 렌더링
     - Solitary 테스트는 자식 컴포넌트를 모킹해서 렌더링
3. 통합(Integration) 테스트
   - 두 개 이상의 모듈이 실제로 연결된 상태를 테스트하는 것
   - 그리하여 모듈 간의 연결에서 발생하는 에러를 검증할 수 있으며, 단위테스트보다 비교적 넓은 범위에서 테스트하기 때문에 리팩토링에 쉽게 깨지지 않는 장점
   - ![integration-test](https://martinfowler.com/bliki/images/integrationTesting/sketch.png)
   - 단위 테스트와 마찬가지로 테스트 더블의 사용 여부에 따라 broad test와 narrow test로 구분
     - broad test: 의존성이 있는 모든 모듈이 연결된 상태를 테스트
     - narrow test: 연결된 모듈을 테스트 더블로 대체하여 테스트
   - **프론트엔드**에서 통합 테스트는 UI와 API 간의 상호작용이 올바르게 일어나는지, 또는 state에 따른 UI의 변경이 올바르게 동작하는지를 확인하는 것
   - 따라서 실제 API를 호출하여 broad test를 하거나 API client를 모킹(mocking) 하거나 가상 API 서버를 이용함으로써 narrow test를 수행할 수 있음.
   - [추가로 읽어보면 좋은 글](https://yeoulcoding.me/245) - Next.js에서 통합 테스트 적용 사례
     - > 모듈을 나누는 단위는 사용자에게 보여지는 "화면"을 기준으로 구성하는 것이 좋습니다.
     - > 테스트 환경은 웹 서비스의 특성상 브라우저 환경에서 테스트하는 것이 가장 좋습니다.
       - 브라우저의 기능을 별도의 모킹 없이 그대로 사용할 수 있기 때문
4. E2E(End to End) 테스트
   - 실제 사용자의 입장 및 환경에서 테스트하는 것
   - **프론트엔드**에서 E2E 테스트는 실제 브라우저를 실행해서 테스트하는 것을 말하며,
   - 커버리지가 높고 실제 상황에서 발생할 수 있는 에러를 검출할 수 있단 장점
   - 브라우저를 띄우기 때문에 Web API를 활용할 수 있고 테스트 코드가 내부 구조에 영향을 받지 않기 때문에 코드의 변경에도 비교적 잘 깨지지 않는 장점
   - 그러나 브라우저를 띄우기 때문에 단위, 통합 테스트보다 실행 속도가 느리고 테스트의 실행 환경에서 발생하는 문제들(네트워크 에러 등)로 인해 테스트가 실패할 수 있어서 E2E 테스트의 결과를 신뢰하기 어려운 단점
   - API 서버, DB 등의 외부 서비스들을 모두 사용하여 통합된 시스템을 테스트
   - 단위/통합 테스트에 비해 작성이 어렵고 실행 속도가 가장 느림
   - 문제가 생긴 부분을 정확히 파악하기가 가장 어려움

<br />

## 프론트엔드에서의 테스트 대상

1. 시각적 요소
   - 스냅샷 테스트: 실제 결과와 스냅샷 해놓은 성공한 결과(트리 구조)를 비교하면서 테스트하는 방법
     - ex: Jest
   - 시각적 회귀 테스트(Visual Regression Test)
     - ex: Chromatic
2. 사용자 이벤트 처리
   - 사용자의 마우스, 키보드 등의 입력 이벤트를 적절한 이벤트 핸들러로 처리하는 작업
   - 이를 테스트하기 위해 자바스크립트 API 또는 React와 같은 라이브러리에서 제공하는 테스트 유틸리티를 활용하여 이벤트를 시뮬레이션하거나, E2E 테스트를 통해서 실제로 브라우저상에서 이벤트를 발생
   - Node.js 환경에서 테스트하는 경우 React 팀이 권장하는 테스트 도구인 react-testing-library에서 제공하는 패키지를 활용하면 사용자 이벤트를 보다 효율적으로 시뮬레이션 할 수 있음.
3. API 서버 통신
   - 브라우저 API 또는 라이브러리를 활용하여 API 서버와 통신하고 애플리케이션 상태를 동기화하는 작업
   - API 서버와의 통신을 테스트하는 방법
     1. 실제 API 서버를 이용하는 방법이 있으며 이 방법은 E2E 테스트에서 주로 사용
     2. 테스트 API 서버를 구축하거나 **API client를 모킹(Mocking)하는 방법**
        - 이렇게 API client를 모킹하면 API 요청에 대한 응답을 원하는 대로 수정할 수 있기 때문에 다양한 상황을 테스트할 수 있다는 장점
        - Jest를 활용하면 모듈을 간단한 방법으로 모킹할 수 있기 때문에 testing-library와 마찬가지로 Jest를 테스트 도구로 활용할 것을 React 팀에서 권장함

<br />

## 테스트 환경

1. 브라우저 환경

   - 브라우저 환경에서 테스트 코드를 실행하면 모든 Web API에 접근할 수 있단 것이 큰 장점
   - 서로 다른 브라우저에서 테스트 할 수 있기 때문에 브라우저 호환성 및 기기 호환성 테스트 가능
   - 브라우저의 프로세스가 Node.js 프로세스보다 무겁기 때문에 실행 속도가 느리다는 단점
   - 브라우저를 실행해야 하므로 대부분의 경우 브라우저 런처를 별도로 설치해야 한다는 제약
   - 따라서 속도 문제를 해결하기 위해 UI 인터페이스를 제외한 \*Headless 브라우저를 사용하고 개발이 완료되어 배포할 때만 CI와 연동해서 테스트하는 방식이 권장됨
     - \*Headless Browser
       > A headless browser is a web browser without a graphical user interface.
       - 말 그대로 GUI 환경이 아닌, CLI에서 동작하는 브라우저

2. Node.js 환경

   - 테스트 코드를 Node.js 환경에서 실행하는 것은 브라우저 환경보다 속도가 빠르다는 장점
   - 단위 테스트는 빠른 피드백이 중요 -> 가볍고 빠른 Node 환경이 적합.
   - 개별 테스트를 별도의 프로세스에서 실행 ⇒ 안전한 테스트 환경
   - 이 방식의 중요한 단점은 브라우저의 모든 API를 제대로 활용할 수 없다는 것
   - 이러한 문제를 극복하기 위해 **Jest**와 같은 테스트 도구들은 **jsdom**처럼 DOM을 가상으로 구현하는 라이브러리를 활용하고 있는데, 여전히 페이지 내비게이션이나 레이아웃과 같은 것들은 테스트할 수 없다는 제약
   - 당연히 크로스 브라우징과 같은 다양한 환경에서의 테스트 할 수도 없음.

3. 정리
   - React 공식 문서에서는 브라우저 환경과 Node.js 환경에서 테스트하는 것에 대한 트레이드 오프(Trade off)가 존재한다고 설명함. 위 두 가지 환경에서 테스트하는 것은 테스트 실행 속도와 실제 환경에서 테스트 함으로써 얻을 수 있는 이점 두 가지 측면에서 서로 대비되기 때문.
   - TOAST UI 팀은 크로스 브라우징 또는 렌더링, 내비게이션 등 브라우저의 **실제 동작**을 테스트해야 하는 경우 브라우저 환경에서 테스트하고, 그 외의 경우 Node.js 환경에서 테스트하는 것을 권장하고 있음. ([참고](https://ui.toast.com/fe-guide/ko_TEST#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-vs-nodejs))
   - 그 이유는 오늘날 대부분 브라우저들의 구현 차이가 거의 없어졌고, babel로 최신 JS 문법을 트랜스파일링 함으로써 오래된 브라우저 지원도 가능하며 jsdom 으로 DOM을 구현한 뒤 React와 프레임워크에서 제공하는 API를 활용하면 DOM 조작도 가능하기 때문

<br />

## 테스팅 툴

- (단위/통합테스트 관점에 집중하여 정리하였음)
- 용어 정리
  - 테스트 러너: 테스트를 구동할 수 있는 환경을 제공
  - 테스트 프레임워크: 테스트 코드를 작성할 수 있는 기반을 제공
  - 단언(assertion) 라이브러리: 테스트가 통과하기 위한 조건을 명확하게 기술할 수 있게 함(`toBe(123)`, `toBeNull` 등과 같은 jest의 matchers)
  - 테스트 더블 라이브러리: 실제 객체 대신 테스트를 위해 동작하는 객체(mock, spy, stub 등)
- Node.js 환경에서는 React 공식 문서에서 권장하는 테스트 도구인 **Jest**와 **React Testing Library**를 활용할 수 있다.
- 브라우저 환경에서는 E2E 테스트 도구들을 제외한다면 현재로서는 Karma를 사용하는 것이 단위/통합 테스트에서의 유일한 방법(Karma는 테스트 러너의 역할만 하기 때문에 별도의 테스트 프레임워크가 추가로 필요하며, 보통 Jasmine을 사용하기를 권장)
- 브라우저 환경에서는 여러 E2E 테스트 도구를 활용하여 E2E 테스트 및 크로스 브라우징 테스트를 수행할 수 있다.
  - 특히 E2E 테스트 도구로 많이 쓰이는 cypress와 playwright가 있는데 **playwright**는 cypress와 달리 무료로 병렬로 테스트를 제공하며 병렬로 수행하기 때문에 테스트 속도가 더 빠르다는 장점이 있다.

<br />

1. Jest

   - 페이스북에서 만든 JS 테스팅 라이브러리, 테스트 러너(테스트를 실행할 수 있는 환경을 제공)
   - 현재 페이스북 내의 모든 JS 테스트에 사용됨.
   - 프론트엔드 뿐만 아니라 Node.js 환경에 구축된 백엔드 애플리케이션도 테스트 가능
   - 단언(assertion)뿐만 아니라 모킹, 스냅샷 테스팅, 코드 커버리지 등 다양한 API를 제공
   - Node 환경에서 JSDom을 이용해 테스트(브라우저 테스트 불가)

2. React-Testing-Libaray(RTL)

   - React Component를 테스트하기 위해 제작된 자바스크립트 테스트 유틸리티
   - 각각의 구성요소에 대한 사용자 상호작용을 테스트하고, UI가 올바르게 작동하는지 확인함
   - jest와 react-testing-library는 상호보완적인 관계
     - react-testing-library는 jest의 대체품이 아니다! 리액트 컴포넌트 테스트를 하려면 어차피 둘 다 필요함
   - **jsdom**이라는 라이브러리를 통해 가상돔을 제공해주기 때문에 브라우저없이 테스트 가능
   - 사용자의 관점에서 테스팅하기에 더 용이함
   - 모든 테스트를 DOM 위주로 진행함
   - 컴포넌트를 리팩토링하게 될 때에는, 주로 내부 구조 및 네이밍은 많이 바뀔 수 있어도 실제 작동 방식은 크게 바뀌지 않는데, react-testing-library는 이 점을 중요시 여겨서 컴포넌트의 기능이 똑같이 작동한다면 컴포넌트의 내부 구현 방식이 많이 바뀌어도 테스트가 실패하지 않도록 설계되었다고 함.
   - [RTL 적용 예시](https://velog.io/@velopert/react-testing-library)
   - [RTL 적용 예시2](https://tecoble.techcourse.co.kr/post/2021-10-22-react-testing-library/)

3. playwright

   - 브라우저 환경에서 빠르고 안정적인 자동화를 지원하는 도구
   - 클릭과 같은 액션을 실행하기 전, 엘리먼트가 준비될 때까지 자동으로 기다린다는 장점
   - 네트워크 요청을 모킹하기 위한 네트워크 활동 가로채기
   - 마우스, 키보드의 기본 입력 이벤트
   - 브라우저 인스턴스를 시작하고 - 브라우저 인스턴스를 닫는 것으로 끝나는 흐름

4. Storybook - Chromatic

5. Karma
   - 브라우저 환경에서 유닛 테스트를 할 수 있는 유일한 테스트 러너

<br />
<br />

참고:

- https://ui.toast.com/fe-guide/ko_TEST

- https://velog.io/@velopert/react-testing

- https://blog.mathpresso.com/%EB%AA%A8%EB%8D%98-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A0%84%EB%9E%B5-1%ED%8E%B8-841e87a613b2

- https://kooku0.github.io/blog/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C%20%EC%A7%9C%EA%B8%B0/

- [테스트 더블](https://martinfowler.com/bliki/TestDouble.html)

- [React 공식 문서 - 테스팅 개요](https://ko.reactjs.org/docs/testing.html)

- [cypress vs playwright](https://emewjin.github.io/playwright-vs-cypress/)

- https://ui.toast.com/weekly-pick/ko_20210818

- https://nhnent.dooray.com/share/posts/9jRYF1fxRwiCvwi6VM0VgA
